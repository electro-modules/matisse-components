<?php

namespace Electro\Plugins\MatisseComponents\Handlers;

use Electro\ContentRepository\Config\ContentRepositorySettings;
use Electro\ContentRepository\Lib\FileUtil;
use Electro\Exceptions\FlashMessageException;
use Electro\Exceptions\FlashType;
use Electro\Interfaces\ContentRepositoryInterface;
use Electro\Interfaces\ModelControllerExtensionInterface;
use Electro\Interfaces\ModelControllerInterface;
use Electro\Plugins\IlluminateDatabase\BaseModel;
use Electro\Plugins\MatisseComponents\Models\File;
use Electro\Plugins\MatisseComponents\Traits\FilesModelTrait;
use Illuminate\Database\Query\Builder;
use Psr\Http\Message\UploadedFileInterface;

/**
 * Handles file uploads for the FileField and ImageField components.
 *
 * Warning: files on sub-models are NOT supported!
 */
class FileFieldHandler implements ModelControllerExtensionInterface
{
  const FILE_FIELD_SUFFIX = '_FileField';

  /** @var string */
  private $fileArchivePath;
  /** @var ContentRepositoryInterface */
  private $repository;

  public function __construct (ContentRepositorySettings $settings, ContentRepositoryInterface $repository)
  {
    $this->fileArchivePath = $settings->fileArchivePath;
    $this->repository      = $repository;

    // Watch for file model deletions and remove the corresponding physical files.
    File::deleting (function (File $model) use ($repository) {
      if (exists ($model->path))
        $repository->deleteFile ($model->path);
    });
  }

  /*
   * Detect if the request has fields that were generated by this component; if so, register an handler for saving
   * them.
   */
  function modelControllerExtension (ModelControllerInterface $modelController)
  {
    $request = $modelController->getRequest ();
    $files   = $request->getUploadedFiles ();

    $uploads = [];

    $this->processDropzoneFiles($request, $modelController);

    // Check if extension is applicable to the current request.
    foreach ($files as $fieldName => $file)
      if (str_endsWith ($fieldName, self::FILE_FIELD_SUFFIX)) {
        // Note: slashes are converted to dots, which delimit path segments to nested fields. See the Field component.
        $fieldName           = str_replace ('/', '.', str_segmentsStripLast ($fieldName, self::FILE_FIELD_SUFFIX));
        $uploads[$fieldName] = $file;
      }

      if ($uploads)
        $modelController->onSave (-1, function () use ($uploads, $modelController) {
          /** @var UploadedFileInterface $file */
          foreach ($uploads as $fieldName => $file) {
            list ($targetModel, $prop) = $modelController->getTarget ($fieldName);
            $err = $file->getError ();
            if ($err == UPLOAD_ERR_OK)
              static::newUpload ($targetModel, $prop, $file);
            else if ($err == UPLOAD_ERR_NO_FILE)
              static::noUpload ($targetModel, $prop);
            else throw new FlashMessageException ("Error $err", FlashType::ERROR, "Error uploading file");
          }
        });
  }

  private function processDropzoneFiles($request,$modelController)
  {
    $oParsedBody = $request->getParsedBody();
    if (!$oParsedBody)
      return;
    foreach ($oParsedBody as $fieldName => $value)
    {
      $model = $modelController->getModel();
      $fieldName = str_replace('model/','',$fieldName);
      if (in_array($fieldName, $model::GALLERY_FIELDS))
      {
        $filesRelation = $model->files ();
        $arrFilePaths = explode(',', $value);

        // regista novos uploads feitos a partir do sistema
        foreach ($arrFilePaths as $filePath)
        {
          if (strpos($filePath,sys_get_temp_dir())!==false)
          {
            if (!fileExists($filePath))
              continue;

            $a = explode(DIRECTORY_SEPARATOR,$filePath);
            $fileName = end($a);
            $data = File::getFileData ($fileName,$filePath,$fieldName);
            $fileModel = $filesRelation->create ($data);
            $this->repository->saveFile($fileModel->path, $filePath,$data['mime']);

            $model->$fieldName = str_replace($filePath, $fileModel->path, $model->$fieldName);

            if (fileExists($filePath))
              unlink($filePath);
          }
        }

        // verifica se nÃ£o existe imagens para apagar
        $arrFilePaths = explode(',', $model->$fieldName);
        $bWhereCondi = false;
        $arrFilesToKeep = [];
        $oFilesToDelete = $filesRelation->where('group',$fieldName);
        foreach ($arrFilePaths as $filePath)
        {
          if (strpos($filePath,sys_get_temp_dir())===false) {
            $bWhereCondi = true;
            $arrFilesToKeep[$filePath] = $filePath;
          }
        }

        if ($bWhereCondi)
        {
          $oFilesToDelete->whereNotIn('path',$arrFilesToKeep);
          foreach ($oFilesToDelete->get() as $oFileToDelete) {
            $this->repository->deleteFile($oFileToDelete->path);
            $oFileToDelete->delete();
          }
        }
      }
    }
  }

  /**
   * Handle the case where a file has been uploaded for a field, possibly replacing another already set on the field.
   *
   * @param BaseModel|FilesModelTrait $model
   * @param string                    $fieldName
   * @param UploadedFileInterface     $file
   * @throws \Exception
   * @throws \League\Flysystem\FileExistsException
   * @throws \League\Flysystem\InvalidArgumentException
   */
  private function newUpload (BaseModel $model, $fieldName, UploadedFileInterface $file)
  {
    // Check is there are already files on this field.
    $filesRelation = $model->files ();
    /** @var Builder $filesQuery */
    $filesQuery = $filesRelation->ofField ($fieldName);
    /** @var File[] $files */
    $files = $filesQuery->get ();

    // Save new file
    $data = File::getFileData ($file->getClientFilename (), FileUtil::getUploadedFilePath ($file), $fieldName);
    /** @var File $fileModel */
    $fileModel = $filesRelation->create ($data);
    $this->repository->saveUploadedFile ($fileModel->path, $file);

    // Delete the previous files of this field, if any exists.
    // This is only performed AFTER the new file is successfully uploaded.
    foreach ($files as $file)
      $file->delete ();

    // If everything went ok, save the models.
    if (!in_array ($fieldName, $model::GALLERY_FIELDS))
      $model[$fieldName] = $fileModel->path;
    $model->save ();
  }

  /**
   * Handle the case where no file has been uploaded for a field, but the field may have been cleared.
   *
   * @param BaseModel|FilesModelTrait $model
   * @param string                $fieldName
   * @throws \Exception
   */
  private function noUpload (BaseModel $model, $fieldName)
  {
    if (!isset ($model[$fieldName])) {
      // Check is there are already files on this field.
      $filesRelation = $model->files ();
      /** @var Builder $filesQuery */
      $filesQuery = $filesRelation->ofField ($fieldName);
      /** @var File[] $files */
      $files = $filesQuery->get ();

      // Delete the previous files of this field, if any exists.
      foreach ($files as $file)
        $file->delete ();
    }
  }

}
